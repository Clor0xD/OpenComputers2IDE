---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by User.
--- DateTime: 20.04.2022 20:14
---
local Class = require('libEx/Class')
local sides = require("sides")
---@class Position:Class
local Position = Class:extended({
    class = "Class Position"
})

---@class PositionSide
Position.side = {
    north = 0,
    east = 1,
    south = 2,
    west = 3,
    negZ = 0,
    posX = 1,
    posZ = 2,
    negX = 3
}

---@class PositionSidesBySide
Position.sidesBySide = {
    [Position.negZ] = sides.negz,
    [Position.posX] = sides.posx,
    [Position.posZ] = sides.posz,
    [Position.negX] = sides.negx
}

---@class PositionSideBySides
Position.sideBySides = {
    [sides.negz] = Position.negZ,
    [sides.posx] = Position.posX,
    [sides.posz] = Position.posZ,
    [sides.negx] = Position.negX
}

---@class PositionTurn
Position.turn = {
    left = -1,
    forward = 0,
    right = 1,
    around = 2,
    back = 2
}

function Position:new(x, y, z, r)
    local instance = self.super:new()
    if not x then
        return self:extendedInstance(instance):set(0, 0, 0, 0)
    end
    return self:extendedInstance(instance):set(x, y, z, r)
end

---@type fun(adjacentPosition:Position):boolean,Sides
function Position:getAdjacentSide(adjacentPosition)
    local list, acc, check, result = table.pack(self.get("yzx"), adjacentPosition.get("yzx")), 0, 0, 0
    for i = 1, 3 do
        check = list[i + 3] - list[i]
        if check == 1 then
            result = i*2-1
        elseif check == -1 then
            result = i*2-2
        end
        acc = acc + check
    end
    return acc == 1 or acc == -1, result
end

function Position:add(position)
    self.x = self.x + position.x
    self.y = self.y + position.y
    self.z = self.z + position.z
    return self
end

function Position:sub(position)
    self.x = self.x - position.x
    self.y = self.y - position.y
    self.z = self.z - position.z
    return self
end

function Position:coordsEquels(position)
    return self.x == position.x and self.y == position.y and self.z == position.z
end

function Position:equels(position)
    return self == position or
               (self.x == position.x and self.y == position.y and self.z == position.z and self.r == position.r)
end

function Position:get(format)
    if format == nil then
        return self.x, self.y, self.z, self.r
    end
    if self:assertFormat(format) then
        local result = {}
        for key in format:gmatch '[xyzr]' do
            table.insert(result, self[key])
        end
        return table.unpack(result)
    end
end

function Position:setf(format, ...)
    self:assertFormat(format)
    local args = table.pack(...)
    assert(#format <= #args, self:tostring() .. ":setf(format, ...) argument (...) very short")
    for i = 1, #format do
        self[format:sub(i, i)] = args[i]
    end

    return self
end

function Position:set(x, y, z, r)
    -- self.x, self.y, self.z, self.r = x, y, z, r
    -- return self
    return self:setf("xyzr", x, y, z, r) -- assert params
end

function Position:clone() -- local returnPos; returnPos = currentPos:clone()
    return self:new(self:get())
end

function Position:copy(position) -- returnPos:copy(currentPos) 
    return self:set(position:get())
end

function Position:getCoordinatesUp()
    local x, y, z, r = self:get()
    return x, y + 1, z, r
end

function Position:getCoordinatesDown()
    local x, y, z, r = self:get()
    return x, y - 1, z, r
end

function Position:getCoordinatesLocalRotation(turn)
    self:getCoordinatesGlobalRotation((turn + self.r) % 4)
end

function Position:getCoordinatesGlobalRotation(side)
    local x, y, z, r = self:get()
    if side == self.side.negZ then
        z = z - 1
    elseif side == self.side.posZ then
        z = z + 1
    elseif side == self.side.negX then
        x = x - 1
    elseif side == self.side.posX then
        x = x + 1
    end
    return x, y, z, r
end

function Position:turnRight()
    self.r = (self.r + 1) % 4
    return self
end

function Position:turnLeft()
    self.r = (self.r - 1) % 4
    return self
end

function Position:turnAround()
    self.r = (self.r + 2) % 4
    return self
end

function Position:stepUp()
    self.y = self.y + 1
    return self
end

function Position:stepDown()
    self.y = self.y - 1
    return self
end

function Position:stepForward()
    return self:stepBase(1)
end

function Position:stepBack()
    return self:stepBase(-1)
end

---@private
function Position:assertFormat(format, message)
    if not format or type(format) ~= 'string' then
        format = type(format)
        -- if not massage then
        message = ' incorrect argument format type : ' .. format .. ' [xyzr] string only'
        -- end
        error(self:tostring() .. message)
    end
    if #format == 0 then
        -- if not massage then
        message = 'incorrect argument format : empty_string'
        -- end
        error(self:tostring() .. message)
    end
    if not massage then
        message = ' incorrect argument format : ' .. format .. ' [xyzr] only'
    end
    return assert(not format:match '[^xyzr]', self:tostring() .. message)
end

---@private
function Position:stepBase(dir)
    if self.r == self.side.negZ then
        self.z = self.z - dir
    elseif self.r == self.side.posZ then
        self.z = self.z + dir
    elseif self.r == self.side.negX then
        self.x = self.x - dir
    elseif self.r == self.side.posX then
        self.x = self.x + dir
    end
    return self
end

return Position
