---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by User.
--- DateTime: 20.04.2022 20:14
---
local Class = require('libEx/Class')
local sides = require("sides")

---@class Position:Class
---@field public x number
---@field public y number
---@field public z number
---@field public r PositionSide
local Position = Class:extended({
    class = "Class Position"
})

---@class PositionSide
Position.side = {
    north = 0,
    east = 1,
    south = 2,
    west = 3,
    negZ = 0,
    posX = 1,
    posZ = 2,
    negX = 3
}

---@class PositionSidesBySide
Position.sidesBySide = {
    [Position.side.negZ] = sides.negz,
    [Position.side.posX] = sides.posx,
    [Position.side.posZ] = sides.posz,
    [Position.side.negX] = sides.negx
}

---@class PositionSideBySides
Position.sideBySides = {
    [sides.negy] = Position.side.negZ,
    [sides.posy] = Position.side.negZ,
    [sides.negz] = Position.side.negZ,
    [sides.posx] = Position.side.posX,
    [sides.posz] = Position.side.posZ,
    [sides.negx] = Position.side.negX
}

---@class PositionTurn
Position.turn = {
    left = -1,
    forward = 0,
    right = 1,
    around = 2,
    back = 2
    -- left = 3
}

---@param x number
---@param y number
---@param z number
---@param r PositionSide
---@return Position
function Position:new(x, y, z, r)
    local instance = self.super:new()
    if not x then
        return self:extendedInstance(instance):set(0, 0, 0, 0)
    end
    return self:extendedInstance(instance):set(x, y, z, r)
end

---@param adjacentPosition Position
---@return boolean,Sides @staus globalRotation:Sides_openOs
function Position:getAdjacentSide(adjacentPosition)
    local this, adjacent, acc, check, result = self:get("yzx", true), adjacentPosition:get("yzx", true), 0, 0, 0
    for i = 1, 3 do
        check = adjacent[i] - this[i]
        if check == 1 then
            result = i * 2 - 1
        elseif check == -1 then
            result = i * 2 - 2
        end
        acc = acc + check
    end
    return acc == 1 or acc == -1, result
end

---@ changes self
---@param positionORx Position
---@param y number
---@param z number
---@return Position @self
function Position:add(positionORx, y, z)
    if type(positionORx) == "table" then
        self.x = self.x + positionORx.x
        self.y = self.y + positionORx.y
        self.z = self.z + positionORx.z
        return self
    end
    self.x = self.x + positionORx
    self.y = self.y + y
    self.z = self.z + z
    return self
end

---@ changes self
---@param position Position
---@return Position @self
function Position:sub(positionORx, y, z)
    if type(positionORx) == "table" then
        self.x = self.x - positionORx.x
        self.y = self.y - positionORx.y
        self.z = self.z - positionORx.z
        return self
    end
    self.x = self.x - positionORx
    self.y = self.y - y
    self.z = self.z - z
    return self
end

---@ does not change sefl, args
---@param position Position
---@return number, number, number @x,y,zlua
function Position:subCortage(position)
    return self.x - position.x, self.y - position.y, self.z - position.z
end

function Position:coordsEquels(position)
    return self.x == position.x and self.y == position.y and self.z == position.z
end

function Position:equels(position)
    return self == position or
               (self.x == position.x and self.y == position.y and self.z == position.z and self.r == position.r)
end

function Position:get(format, isPack)
    if format == nil then
        if isPack then
            return {self.x, self.y, self.z, self.r}
        end
        return self.x, self.y, self.z, self.r
    end
    if self:assertFormat(format) then
        local result = {}
        for key in format:gmatch '[xyzr]' do
            table.insert(result, self[key])
        end
        if isPack then
            return result
        end
        return table.unpack(result)
    end
end

function Position:setf(format, ...)
    self:assertFormat(format)
    local args = table.pack(...)
    assert(#format <= #args, self:tostring() .. ":setf(format, ...) argument (...) very short")
    for i = 1, #format do
        self[format:sub(i, i)] = args[i]
    end

    return self
end

function Position:set(x, y, z, r)
    -- self.x, self.y, self.z, self.r = x, y, z, r
    -- return self
    return self:setf("xyzr", x, y, z, r) -- assert params
end

function Position:clone() -- local returnPos; returnPos = currentPos:clone()
    return self:new(self:get())
end

function Position:copy(position) -- returnPos:copy(currentPos) 
    return self:set(position:get())
end

function Position:getCoordinatesUp(distance)
    if not distance or distance == 0 then
        distance = 1
    end
    local x, y, z, r = self:get()
    return x, y + distance, z, r
end

function Position:getCoordinatesDown(distance)
    if not distance or distance == 0 then
        distance = 1
    end
    local x, y, z, r = self:get()
    return x, y - distance, z, r
end

---@param turn PositionTurn
function Position:getCoordinatesLocalRotation(turn, distance)   
    self:getCoordinatesGlobalRotation((turn + self.r) % 4, distance)
end

function Position:getCoordinatesGlobalRotation(side, distance)
    if not distance or distance == 0 then
        distance = 1
    end
    local x, y, z, r = self:get()
    if side == self.side.negZ then
        z = z - distance
    elseif side == self.side.posZ then
        z = z + distance
    elseif side == self.side.negX then
        x = x - distance
    elseif side == self.side.posX then
        x = x + distance
    end
    return x, y, z, r
end

---@param turn PositionTurn
function Position:shift(turn, distanceH, distanceV, isTurn)
    turn = (turn + self.r) % 4
    self.y = self.y + distanceV
    if turn == self.side.negZ then
        z = z - distanceH
    elseif turn == self.side.posZ then
        z = z + distanceH
    elseif turn == self.side.negX then
        x = x - distanceH
    elseif turn == self.side.posX then
        x = x + distanceH
    end
    if isTurn then
        self.r = turn
    end
    return self
end

function Position:turnRight()
    self.r = (self.r + 1) % 4
    return self
end

function Position:turnLeft()
    self.r = (self.r - 1) % 4
    return self
end

function Position:turnAround()
    self.r = (self.r + 2) % 4
    return self
end

function Position:stepUp()
    self.y = self.y + 1
    return self
end

function Position:stepDown()
    self.y = self.y - 1
    return self
end

function Position:stepForward()
    return self:stepBase(1)
end

function Position:stepBack()
    return self:stepBase(-1)
end

---@param globalRotation PositionSide
function Position:calculateTurn(globalRotation)
    return ((globalRotation - self.r) + 4) % 4
end

---@private
function Position:assertFormat(format, message)
    if not format or type(format) ~= 'string' then
        format = type(format)
        -- if not massage then
        message = ' incorrect argument format type : ' .. format .. ' [xyzr] string only'
        -- end
        error(self:tostring() .. message)
    end
    if #format == 0 then
        -- if not massage then
        message = 'incorrect argument format : empty_string'
        -- end
        error(self:tostring() .. message)
    end
    if not massage then
        message = ' incorrect argument format : ' .. format .. ' [xyzr] only'
    end
    return assert(not format:match '[^xyzr]', self:tostring() .. message)
end

---@private
function Position:stepBase(dir)
    if self.r == self.side.negZ then
        self.z = self.z - dir
    elseif self.r == self.side.posZ then
        self.z = self.z + dir
    elseif self.r == self.side.negX then
        self.x = self.x - dir
    elseif self.r == self.side.posX then
        self.x = self.x + dir
    end
    return self
end

function Position:toStringDebug()
    return "x: " .. tostring(self.x) .. " y:" .. tostring(self.y) .. " z:" .. tostring(self.z) .. " r:" ..
               tostring(self.r)
end

function Position:print()
    print(self:toStringDebug())
    return self
end

return Position
