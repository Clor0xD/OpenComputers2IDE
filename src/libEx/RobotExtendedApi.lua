---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by SZS.
--- DateTime: 23.04.2022 21:32
---
local Class = require('libEx/Class')

local NativeComputer = require('computer')
local NativeRobotApi = require("robot")
local Position = require('libEx/Position')

NativeRobotApi.class = "Class NativeRobotApi"
NativeComputer.class = "Class NativeComputer"

---@class RobotExApiInitTable
---@field public startPosition Position
---@field public inventoryManager AInventoryManager
---@field public baseStation ABaseStation
---@field public generalBehavior AGeneralBehavior

---@class RobotExtendedApi : NativeRobotApi @extended native OC API robot, computer
---@field position : Position
---@field inventoryManager : AInventoryManager
---@field baseStation : ABaseStation
---@field generalBehavior : AGeneralBehavior
---@field minCharge : number
---@field maxCharge : number
---@field turnToTurnFunction : function[]
---@field movePatternZXY : function[]
---@field movePatternYZX : function[]
local RobotExtendedApi = Class:extended(NativeComputer):extended(NativeRobotApi):extended({
    class = "Class RobotExtendedApi"
})

---@return RobotExtendedApi
---@param initTable RobotExApiInitTable
function RobotExtendedApi:new(initTable)
    local instance = self.super:new()   
    return self:extendedInstance(instance):init(initTable)
end

---@return RobotExtendedApi
---@param initTable RobotExApiInitTable
function RobotExtendedApi:init(initTable)
    local error = ":init(initTable) initTable."
    self.position = self:assert(initTable.startPosition, error .. ".startPosition is nil")
    self.inventoryManager = self:assert(initTable.inventoryManager, "initTable.inventoryManager is nil"):setRobotApi(self.super)
    self.baseStation = self:assert(initTable.baseStation, "initTable.baseStation is nil")
    self.generalBehavior = self:assert(initTable.generalBehavior, "initTable.generalBehavior is nil"):setRobotExApi(self)
    self.maxCharge = self.maxEnergy() - 300
    return self
end

---@follows a position according to the sequence of axes in the movePattern
---@param position Position
---@param movePattern function[] @function[3] RobotExtendedApi goToX/goToY/goToZ
function RobotExtendedApi:goTo(position, movePattern, toTurn, removeObstacle, tries, disableEnergyCheck)
    local dx, dy, dz = position:subCortage(self.position)    
    for i = 1, 3 do
        movePattern[i](self, dx, dy, dz, removeObstacle, tries, disableEnergyCheck)
    end
    if toTurn then
        self:rotateTo(position.r)
    end
end

---@param removeObstacle boolean
---@param tries number
---@return boolean, string @status, error
function RobotExtendedApi:forward(removeObstacle, tries, disableEnergyCheck)
    return self:baseMove(self.super.forward, ":forward()", self.swing, self.position.stepForward, removeObstacle, tries, disableEnergyCheck)
end

-- todo self.moveImpossibleHendler is plug
---@param removeObstacle boolean
---@param tries number
---@return boolean, string @status, error
function RobotExtendedApi:back(removeObstacle, tries, disableEnergyCheck)
    return self:baseMove(self.super.back, ":back()", self.moveImpossibleHendler, self.position.stepBack, removeObstacle,
        tries, disableEnergyCheck)
end

---@param removeObstacle boolean
---@param tries number
---@return boolean, string @status, error
function RobotExtendedApi:up(removeObstacle, tries, disableEnergyCheck)
   return self:baseMove(self.super.up, ":up()", self.swingUp, self.position.stepUp, removeObstacle, tries, disableEnergyCheck)
end

---@param removeObstacle boolean
---@param tries number
---@return boolean, string @status, error
function RobotExtendedApi:down(removeObstacle, tries, disableEnergyCheck)
    return self:baseMove(self.super.down, ":down()", self.swingDown, self.position.stepDown, removeObstacle, tries, disableEnergyCheck)
end

function RobotExtendedApi:left()
    self.turnLeft()
    self.position:turnLeft()
end

function RobotExtendedApi:right()
    self.turnRight()
    self.position:turnRight()
end

function RobotExtendedApi:around()
    self:right()
    self:right()
end

---@param globalRotation PositionSide
function RobotExtendedApi:rotateTo(globalRotation)
    self.turnToTurnFunction[self.position:calculateTurn(globalRotation)](self)
end

function RobotExtendedApi:swing(disableEnergyCheck)
    return self:baseSwing(self.super.swing, ":swing()",disableEnergyCheck)
end

function RobotExtendedApi:swingUp(disableEnergyCheck)
    return self:baseSwing(self.super.swingUp, ":swingUp()",disableEnergyCheck)
end

function RobotExtendedApi:swingDown(disableEnergyCheck)
    return self:baseSwing(self.super.swingDown, ":swingDown()",disableEnergyCheck)
end

---@param sampleStack NativeStack
---@return boolean,string @status, error
function RobotExtendedApi:place(sampleStack)
    self:basePlace(self.super.place, ":place()", sampleStack)
end

---@param sampleStack NativeStack
---@return boolean,string @status, error
function RobotExtendedApi:placeUp(sampleStack)
    self:basePlace(self.super.placeUp, ":placeUp()", sampleStack)
end

---@param sampleStack NativeStack
---@return boolean,string @status, error
function RobotExtendedApi:placeDown(sampleStack)
    self:basePlace(self.super.placeDown, ":placeDown()", sampleStack)
end

---@param funcName string @ up, down, forward, back
---@param status boolean
---@param error string @ impossible move, not enough energy or robot.detect would return. https://ocdoc.cil.li/api:robot
function RobotExtendedApi:moveImpossibleHendler(funcName, status, error)
    self:error(tostring(funcName) .. " move is impossible")
end

function RobotExtendedApi:swingImpossibleHendler(funcName, status, message)
    self:error(":" .. funcName .. " " .. message .. " is impossible")
end

---@param funcName string
---@param status boolean
---@return boolean @status
function RobotExtendedApi:noSuppliesHandler(funcName, status)
    self:error(":" .. funcName .. " not enough supplies")
end

---@private
---@param nativeMoveFunc function
---@param moveFuncName string
---@param swingFunc function
---@param movePositionFunc function
---@param removeObstacle boolean
---@param tries number
---@return boolean, string @status, error
function RobotExtendedApi:baseMove(nativeMoveFunc, moveFuncName, swingFunc, movePositionFunc, removeObstacle, tries, disableEnergyCheck)    
    self:checkRecharge(disableEnergyCheck)        
    local status, error = nativeMoveFunc()
    if status then
        -- self.position:stepForward()
        movePositionFunc(self.position)
        return status, error
    end
    if removeObstacle then
        while not tries or tries > 0 do
            -- self:swing()
            swingFunc(self, disableEnergyCheck)
            status, error = nativeMoveFunc()
            if status then
                -- self.position:stepForward()
                movePositionFunc(self.position)
                return status, error
            end
            if tries then
                tries = tries - 1
            end
        end
    end
    return self:moveImpossibleHendler(moveFuncName, status, error)
end

---@private
function RobotExtendedApi:baseSwing(nativeSwingFunc, funcName, disableEnergyCheck)
    self:checkRecharge(disableEnergyCheck)
    if not self.inventoryManager:checkSelectedTool() then
        self.generalBehavior:toolService(self)
    end
    local status, message = nativeSwingFunc()
    if not status then
        if message ~= 'entity' then
            for tool in self.inventoryManager:nextToolToRemoveBlockIterator() do
                status, message = nativeSwingFunc()
                if status then
                    break
                end
            end
            self.inventoryManager:selectDefaultTool()
            if not status then
                return self:swingImpossibleHendler(funcName, status, error)
            end
        end
    end
end

---@param nativePlaceFunc function
---@param sampleStack NativeStack
---@param funcName string
---@return  boolean, string @status, error
function RobotExtendedApi:basePlace(nativePlaceFunc, funcName, sampleStack, disableEnergyCheck)
    self:checkRecharge(disableEnergyCheck)
    if not self.inventoryManager:selectStack(sampleStack) then
        local status = self.generalBehavior:inventoryRefill(self)
        if not status then
            return self:noSuppliesHandler(funcName, status)
        end
        self:assert(self.inventoryManager:selectStack(sampleStack), ":" .. funcName .. " not enough supplies")
    end
    return nativePlaceFunc()
end

---@param count number
---@param moveFunction function
---@return boolean, string, number @status, error, count
function RobotExtendedApi:multiStep(count, moveFunction, ...)
    if count == 0 then
        return true, nil, 0
    end
    local result, error
    for step = 1, count, 1 do
        result, error = moveFunction(self, ...)
        if not result then
            return result, error, step - 1
        end
    end
    return result, error, count
end

function RobotExtendedApi:goToX(dx, _, _, ...)
    if dx > 0 then
        self:rotateTo(self.position.side.posX)
    elseif dx < 0 then
        self:rotateTo(self.position.side.negX)       
    end    
    self:multiStep(math.abs(dx), self.forward, ...)
end

function RobotExtendedApi:goToY(_, dy, _, ...)   
    if dy > 0 then
        self:multiStep(math.abs(dy), self.up, ...)
    else
        self:multiStep(math.abs(dy), self.down, ...)
    end
end

function RobotExtendedApi:goToZ(_, _, dz, ...)  
    if dz > 0 then
        self:rotateTo(self.position.side.posZ)
    elseif dz < 0 then
        self:rotateTo(self.position.side.negZ)       
    end    
    self:multiStep(math.abs(dz), self.forward, ...)
end

---@return void @nil
function RobotExtendedApi:checkRecharge(disableCheck)
    if not disableCheck and self.energy() < self.minCharge then
        self.generalBehavior:recharge(self)
    end
end

---@return boolean @status
function RobotExtendedApi:isCharged()
    return self.energy() >= self.maxCharge       
end

RobotExtendedApi.movePatternZXY = {RobotExtendedApi.goToZ, RobotExtendedApi.goToX, RobotExtendedApi.goToY}
RobotExtendedApi.movePatternYZX = {RobotExtendedApi.goToY,RobotExtendedApi.goToZ, RobotExtendedApi.goToX }
RobotExtendedApi.turnToTurnFunction = { [0] = RobotExtendedApi.nop, [1] = RobotExtendedApi.right, [2] = RobotExtendedApi.around, [3] = RobotExtendedApi.left }
RobotExtendedApi.minCharge = 3000
RobotExtendedApi.maxCharge = RobotExtendedApi.maxEnergy() - 300

return RobotExtendedApi
