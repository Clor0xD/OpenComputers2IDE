---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by User.
--- DateTime: 21.04.2022 9:30
---

local Shape = require('lib/AShape')
local Sphere = Shape:extended({ class = "Class Sphere" })

function Sphere:new(initTable)
    local instance = self.super:new()
    return self:extendedInstance(instance):init():set(initTable)
end

function Sphere:set(initTable)
    local error = ':set(initTable.'
    self.x = self:assertNumberSetDefault(initTable.x, 0, error .. "x)")
    self.y = self:assertNumberSetDefault(initTable.y, 0, error .. "y)")
    self.z = self:assertNumberSetDefault(initTable.z, 0, error .. "z)")
    self.radius = self:assertNumber(initTable.radius, error .. 'radius)')
    self.gridOffsetX = self:assertNumberSetDefault(initTable.gridOffsetX, 0, error .. 'gridOffsetX)')
    self.gridOffsetY = self:assertNumberSetDefault(initTable.gridOffsetY, 0, error .. 'gridOffsetY)')
    self.gridOffsetZ = self:assertNumberSetDefault(initTable.gridOffsetZ, 0, error .. 'gridOffsetZ)')
    self.radiusOffset = self:assertNumberSetDefault(initTable.radiusOffset, 0, error .. 'radius)')
    return self
end

function Sphere:init()
    self.voxelCalcArea = {}
    for i = 0, 2 do
        self.voxelCalcArea[i] = {}
        for j = 0, 2 do
            self.voxelCalcArea[i][j] = {}
        end
    end
    return self
end

function Sphere:calcVoxel(x, y, z)
    for i = 0, 1 do
        for j = 0, 1 do
            for k = 0, 1 do
                if ((x + i + self.gridOffsetX) ^ 2 + (y + j + self.gridOffsetY) ^ 2 + (z + k + self.gridOffsetZ) ^ 2) < (self.radius + self.radiusOffset) ^ 2 then
                    self.voxelCalcArea[i][j][k] = self.voxelType.internal
                else
                    self.voxelCalcArea[i][j][k] = self.voxelType.external
                end
            end
        end
    end
    --calc surface x/i axis
    for j = 0, 1 do
        for k = 0, 1 do
            for i = 1, 0, -1 do
                if self.voxelCalcArea[i][j][k] == self.voxelType.surface then
                    break
                end
                if self.voxelCalcArea[i][j][k] == self.voxelType.internal then
                    self.voxelCalcArea[i][j][k] = self.voxelType.surface
                    break
                end
            end
        end
    end
    --calc surface y/j axis
    for i = 0, 1 do
        for k = 0, 1 do
            for j = 1, 0, -1 do
                if self.voxelCalcArea[i][j][k] == self.voxelType.surface then
                    break
                end
                if self.voxelCalcArea[i][j][k] == self.voxelType.internal then
                    self.voxelCalcArea[i][j][k] = self.voxelType.surface
                    break
                end
            end
        end
    end
    --calc surface z/k axis
    for i = 0, 1 do
        for j = 0, 1 do
            for k = 1, 0, -1 do
                if self.voxelCalcArea[i][j][k] == self.voxelType.surface then
                    break
                end
                if self.voxelCalcArea[i][j][k] == self.voxelType.internal then
                    self.voxelCalcArea[i][j][k] = self.voxelType.surface
                    break
                end
            end
        end
    end
    return self.voxelCalcArea[0][0][0]
end

function Sphere:coordMiroring(x, y, z)
    if self.radius % 2 == 0 then
        if x < 0 then
            x = math.abs(x) - 1
        end
        if y < 0 then
            y = math.abs(y) - 1
        end
        if z < 0 then
            z = math.abs(z) - 1
        end
    else
        if x < 0 then
            x = math.abs(x)
        end
        if y < 0 then
            y = math.abs(y)
        end
        if z < 0 then
            z = math.abs(z)
        end
    end
    return x, y, z
end

function Sphere:coordGlobalToLocal(x, y, z)
    return x - self.x, y - self.y, z - self.z
end

function Sphere:getVoxelLocal(x, y, z)
    return self:calcVoxel(self:coordMiroring(x, y, z))
end

function Sphere:getVoxelGlobal(x, y, z)
    return self:calcVoxel(self:coordMiroring(self:coordGlobalToLocal(x, y, z)))
end

return Sphere
