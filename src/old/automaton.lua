---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by SZS.
--- DateTime: 16.04.2022 14:25
---
local robot_api = require('robot')
local comp = require('component')
local robot = comp.robot
local gps = require('navigation')
local computer = require('computer')

local automaton = {}
automaton.gps = gps
automaton.robot = robot
automaton.robot_api = robot_api
automaton.inventory = require('inventory')
automaton.energyMIN = 5000
automaton.energyMAX = computer.maxEnergy() - 1000

function automaton:_NOP()

end

function automaton:getEnergyValue()
    return computer.energy()
end

function automaton:forward()
    local result, error = robot_api.forward()
    if not result then
        for i = 1, 100 do
            robot_api.swing()
            result, error = robot_api.forward()
            if result then
                self.gps:forward()
                break
            end
        end
    else
        self.gps:forward()
    end
    if not result then
        os.exit('no forward')
    end
    return result, error
end

function automaton:back()
    local result, error = robot_api.back()
    if result then
        self.gps:back()
    end
    return result, error
end

function automaton:up()
    local result, error = robot_api.up()
    if not result then
        for i = 1, 100 do
            robot_api.swingUp()
            result, error = robot_api.up()
            if result then
                self.gps:up()
                break
            end
        end
    else
        self.gps:up()
    end
    if not result then
        os.exit('no up')
    end
    return result, error
end

function automaton:down()
    local result, error = robot_api.down()
    if not result then
        for i = 1, 100 do
            robot_api.swingDown()
            result, error = robot_api.down()
            if result then
                self.gps:down()
                break
            end
        end
    else
        self.gps:down()
    end
    if not result then
        os.exit('no down')
    end
    return result, error
end

function automaton:left()
    robot_api.turnLeft()
    self.gps:turnLeft()
end

function automaton:right()
    robot_api.turnRight()
    self.gps:turnRight()
end

function automaton:around()
    self:right()
    self:right()
end

automaton.rotationTable = { [0] = automaton._NOP, [1] = automaton.right, [2] = automaton.around, [3] = automaton.left }

function automaton:multiStep(count, moveFunction)
    if count == 0 then
        return true, nil, 0
    end
    local result, error
    for step = 1, count, 1 do
        result, error = moveFunction(self)
        if not result then
            return result, error, step - 1
        end
    end
    return result, error, count
end

function automaton:rotateTo(direction)
    self.rotationTable[self.gps:calculateRotation(direction)](self)
end

function automaton:goToX(dx, _, _)
    local _direction
    if dx > 0 then
        _direction = 1
    elseif dx < 0 then
        _direction = 3
    else
        _direction = self.gps.position.r
    end
    self.rotationTable[self.gps:calculateRotation(_direction)](self)
    self:multiStep(math.abs(dx), self.forward)
end

function automaton:goToY(_, dy, _)
    if dy > 0 then
        self:multiStep(math.abs(dy), self.up)
    else
        self:multiStep(math.abs(dy), self.down)
    end
end

function automaton:goToZ(_, _, dz)
    local _direction
    if dz > 0 then
        _direction = 2
    elseif dz < 0 then
        _direction = 0
    else
        _direction = self.gps.position.r
    end
    self.rotationTable[self.gps:calculateRotation(_direction)](self)
    self:multiStep(math.abs(dz), self.forward)
end

function automaton:goTo(position, movePattern)
    local dx, dy, dz
    dx = position.x - self.gps.position.x
    dy = position.y - self.gps.position.y
    dz = position.z - self.gps.position.z
    for i = 1, 3 do
        movePattern[i](self, dx, dy, dz)
    end
    self:rotateTo(position.direction)
end

function automaton:place()
    if self.inventory:selectPlaceSlot() then
        robot_api.place()
        return true
    end
    return false
end

function automaton:placeUp()
    if self.inventory:selectPlaceSlot() then
        robot_api.placeUp()
        return true
    end
    return false
end

function automaton:placeDown()
    if self.inventory:selectPlaceSlot() then
        robot_api.placeDown()
        return true
    end
    return false
end

function automaton:checkToolCharge(minCharge)
    self.inventory.controller.equip()
    local tool = self.inventory.controller.getStackInInternalSlot()
    self.inventory.controller.equip()
    if not tool or not tool.charge then
        return true
    end
    return tool.charge > minCharge
end

return automaton